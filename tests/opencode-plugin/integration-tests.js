/**
 * Open-Reflect OpenCode Plugin Integration Tests
 *
 * Tests cover end-to-end workflows including:
 * - Error scenarios (corrupted JSON, missing files)
 * - Performance (large queues)
 * - Concurrency (multiple operations)
 * - Data integrity (export/import cycles)
 */

const fs = require('fs')
const path = require('path')

console.log("ðŸ§ª Open-Reflect OpenCode Plugin Integration Tests")
console.log("=".repeat(60))
console.log("")

let testsPassed = 0
let testsFailed = 0
const testDir = path.join(process.cwd(), '.test-integration')

// Clean up test directory
function cleanupTestDir() {
  if (fs.existsSync(testDir)) {
    fs.rmSync(testDir, { recursive: true, force: true })
  }
  fs.mkdirSync(testDir, { recursive: true })
}

function test(name, fn) {
  try {
    const result = fn()
    if (result && typeof result.then === 'function') {
      result.then(() => {
        console.log(`âœ… ${name}`)
        testsPassed++
      }).catch((error) => {
        console.log(`âŒ ${name}`)
        console.log(`   Error: ${error}`)
        testsFailed++
      })
    } else {
      console.log(`âœ… ${name}`)
      testsPassed++
    }
  } catch (error) {
    console.log(`âŒ ${name}`)
    console.log(`   Error: ${error}`)
    testsFailed++
  }
}

function expect(actual) {
  return {
    toBe: (expected) => {
      if (actual !== expected) {
        throw new Error(`Expected ${expected} but got ${actual}`)
      }
    },
    toEqual: (expected) => {
      if (JSON.stringify(actual) !== JSON.stringify(expected)) {
        throw new Error(`Expected ${JSON.stringify(expected)} but got ${JSON.stringify(actual)}`)
      }
    },
    toContain: (expected) => {
      if (!actual.includes(expected)) {
        throw new Error(`Expected to contain ${expected}`)
      }
    },
    toBeDefined: () => {
      if (actual === undefined) {
        throw new Error(`Expected to be defined`)
      }
    },
    toThrow: () => {
      let threw = false
      try {
        actual()
      } catch {
        threw = true
      }
      if (!threw) {
        throw new Error(`Expected to throw`)
      }
    }
  }
}

// ============================================================================
// Integration Test Category 1: Error Scenarios
// ============================================================================

console.log("\nðŸ“‹ Category 1: Error Scenarios")
console.log("-".repeat(60))

test("Should handle corrupted JSON gracefully", () => {
  cleanupTestDir()
  const queueFile = path.join(testDir, '.opencode', 'openreflect-queue.json')
  fs.mkdirSync(path.dirname(queueFile), { recursive: true })
  fs.writeFileSync(queueFile, '{invalid json}', 'utf-8')

  try {
    JSON.parse(fs.readFileSync(queueFile, 'utf-8'))
    throw new Error('Should have thrown')
  } catch (error) {
    expect(error.message).toContain('JSON')
  }
})

test("Should validate queue structure before processing", () => {
  const invalidQueue = [
    { id: 123, type: "correction" }
  ]

  const isValid = Array.isArray(invalidQueue) &&
    invalidQueue.every(item => typeof item === "object" && typeof item.id === "string")

  expect(isValid).toBe(false)
})

test("Should handle missing REFLECT.md creation", () => {
  cleanupTestDir()
  const reflectFile = path.join(testDir, 'REFLECT.md')

  if (!fs.existsSync(reflectFile)) {
    const template = `# Open-Reflect Knowledge Evolution Log

> Open-Reflect intermediate learning records

## ðŸŽ¯ Learning Categories
*No learnings yet*

## ðŸ“œ Evolution History
| Version | Date | Change Type | Description |

---
*Generated by Open-Reflect OpenCode Plugin*
`
    fs.mkdirSync(path.dirname(reflectFile), { recursive: true })
    fs.writeFileSync(reflectFile, template, 'utf-8')
  }

  expect(fs.existsSync(reflectFile)).toBe(true)
})

// ============================================================================
// Integration Test Category 2: Large Data Handling
// ============================================================================

console.log("\nðŸ“Š Category 2: Large Data Handling")
console.log("-".repeat(60))

test("Should handle large queue files (1000+ entries)", () => {
  cleanupTestDir()
  const queueFile = path.join(testDir, '.opencode', 'openreflect-queue.json')
  fs.mkdirSync(path.dirname(queueFile), { recursive: true })

  const largeQueue = Array.from({ length: 1000 }, (_, i) => ({
    id: `${i}`,
    type: "correction",
    confidence: 0.8,
    message: `Learning item ${i}`,
    timestamp: new Date().toISOString(),
    project: "test",
    status: "pending"
  }))

  fs.writeFileSync(queueFile, JSON.stringify(largeQueue), 'utf-8')

  const data = JSON.parse(fs.readFileSync(queueFile, 'utf-8'))
  expect(data.length).toBe(1000)
})

test("Should process long messages (>500 chars) with truncation", () => {
  const longMessage = "A".repeat(1000)
  const truncated = longMessage.substring(0, 500)

  expect(truncated.length).toBe(500)
})

// ============================================================================
// Integration Test Category 3: Data Integrity
// ============================================================================

console.log("\nðŸ”’ Category 3: Data Integrity")
console.log("-".repeat(60))

test("Should maintain data consistency during export-import cycle", () => {
  cleanupTestDir()
  const queueFile = path.join(testDir, '.opencode', 'openreflect-queue.json')
  fs.mkdirSync(path.dirname(queueFile), { recursive: true })

  const originalData = [
    {
      id: "1",
      type: "correction",
      confidence: 0.85,
      message: "Test message",
      timestamp: "2024-01-17T00:00:00.000Z",
      project: "test",
      status: "pending"
    }
  ]

  fs.writeFileSync(queueFile, JSON.stringify(originalData), 'utf-8')
  const readData = JSON.parse(fs.readFileSync(queueFile, 'utf-8'))
  expect(JSON.stringify(readData)).toBe(JSON.stringify(originalData))
})

test("Should handle special characters in messages", () => {
  const specialMessages = [
    'Message with "quotes"',
    "Message with 'apostrophes'",
    'Message with \n newlines',
    'Message with \t tabs',
    'Message with Ã©mojis ðŸŽ¯',
    'Message with Unicode: ä½ å¥½ä¸–ç•Œ'
  ]

  for (const msg of specialMessages) {
    const csvSafe = `"${msg.replace(/"/g, '""')}"`
    expect(csvSafe).toBeDefined()
  }
})

// ============================================================================
// Integration Test Category 4: Export Formats
// ============================================================================

console.log("\nðŸ“¤ Category 4: Export Formats")
console.log("-".repeat(60))

test("Should generate valid CSV export format", () => {
  const learning = {
    id: "1",
    type: "correction",
    confidence: 0.85,
    message: 'Test "message" with quotes',
    timestamp: "2024-01-17T00:00:00Z",
    status: "pending"
  }

  const csvLine = `"${learning.id}","${learning.type}",${learning.confidence},"${learning.message.replace(/"/g, '""')}","${learning.timestamp}","${learning.status}"`

  expect(csvLine).toContain('Test')
})

test("Should generate valid JSON export format", () => {
  const learnings = [
    {
      id: "1",
      type: "correction",
      confidence: 0.85,
      message: "Test",
      timestamp: "2024-01-17T00:00:00Z",
      project: "test",
      status: "pending"
    }
  ]

  const json = JSON.stringify(learnings)
  const parsed = JSON.parse(json)

  expect(parsed.length).toBe(1)
  expect(parsed[0].id).toBe("1")
})

test("Should generate valid Markdown export format", () => {
  const markdown = `# Learning Export - 2024-01-17

ðŸ”„ **correction** (85%)
> Test message
> _2024-01-17T00:00:00Z_

`

  expect(markdown).toContain("# Learning Export")
  expect(markdown).toContain("ðŸ”„")
  expect(markdown).toContain("Test message")
})

// ============================================================================
// Integration Test Category 5: Pattern Detection
// ============================================================================

console.log("\nðŸŽ¯ Category 5: Pattern Detection")
console.log("-".repeat(60))

test("Should detect 'I said wrong' pattern with correct confidence", () => {
  const pattern = /I (said|wrote|mentioned)\s+wrong/i
  const confidence = 0.60

  const testStrings = [
    "I said wrong about that",
    "I wrote wrong code",
    "I mentioned wrong approach"
  ]

  for (const str of testStrings) {
    expect(pattern.test(str)).toBe(true)
  }
})

test("Should handle overlapping patterns with priority", () => {
  const patterns = {
    explicit: [
      { pattern: /^remember:/i, confidence: 0.95 }
    ],
    corrections: [
      { pattern: /remember/i, confidence: 0.60 }
    ]
  }

  const message = "remember: use explicit imports"
  let matched = null
  for (const { pattern, confidence } of patterns.explicit) {
    if (pattern.test(message)) {
      matched = { type: "explicit", confidence }
      break
    }
  }

  expect(matched.confidence).toBe(0.95)
})

// ============================================================================
// Integration Test Category 6: Concurrent Operations
// ============================================================================

console.log("\nâš¡ Category 6: Concurrent Scenarios")
console.log("-".repeat(60))

test("Should handle multiple queue reads safely", () => {
  cleanupTestDir()
  const queueFile = path.join(testDir, '.opencode', 'openreflect-queue.json')
  fs.mkdirSync(path.dirname(queueFile), { recursive: true })

  const data = [
    { id: "1", type: "correction", confidence: 0.85, message: "Test", timestamp: "2024-01-17T00:00:00Z", project: "test", status: "pending" }
  ]

  fs.writeFileSync(queueFile, JSON.stringify(data), 'utf-8')

  const read1 = JSON.parse(fs.readFileSync(queueFile, 'utf-8'))
  const read2 = JSON.parse(fs.readFileSync(queueFile, 'utf-8'))

  expect(JSON.stringify(read1)).toBe(JSON.stringify(read2))
})

test("Should safely update queue while maintaining structure", () => {
  cleanupTestDir()
  const queueFile = path.join(testDir, '.opencode', 'openreflect-queue.json')
  fs.mkdirSync(path.dirname(queueFile), { recursive: true })

  const initial = []
  fs.writeFileSync(queueFile, JSON.stringify(initial), 'utf-8')

  const newItem = {
    id: "1",
    type: "correction",
    confidence: 0.85,
    message: "Test",
    timestamp: new Date().toISOString(),
    project: "test",
    status: "pending"
  }

  const data = JSON.parse(fs.readFileSync(queueFile, 'utf-8'))
  data.push(newItem)
  fs.writeFileSync(queueFile, JSON.stringify(data, null, 2), 'utf-8')

  const final = JSON.parse(fs.readFileSync(queueFile, 'utf-8'))
  expect(final.length).toBe(1)
})

// ============================================================================
// Test Summary
// ============================================================================

console.log("\n" + "=".repeat(60))
console.log(`Tests Passed: âœ… ${testsPassed}`)
console.log(`Tests Failed: âŒ ${testsFailed}`)
console.log(`Total Tests: ${testsPassed + testsFailed}`)
console.log("=".repeat(60))

// Cleanup
cleanupTestDir()

// Exit with proper code
if (testsFailed > 0) {
  process.exit(1)
}
